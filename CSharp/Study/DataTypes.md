# 메모리 영역에 따라 구분  
## 값 형식 Value Type
- 스택에 데이터 저장
- 코드 블록 안에서 생성된 모든 값 형식의 변수들은 블록이 끝나면 메모리에서 제거

## 참조 형식 Reference Type
- 힙에 데이터 저장
- 스택에 힙 메모리 주소 저장
- 때문에 데이터 자체는 생명을 유지


# 기본 데이터 형식 Primitive Types

## 1. 숫자 데이터 형식 Numeric Types

### 1.1 정수 계열 형식

번호|데이터 형식|설명|크기(byte)|값의 범위
----|-----|-----|-----|-----
1|byte      |부호 없는 정수                     |1  |0 ~ 255
2|sbyte     |signed byte <br> 정수              |1  |-128 ~ 127
3|short     |정수                               |2  |-32,768 ~ 32,767
4|ushort    |unsigned short<br>부호 없는 정수   |2|0~65,535
5|int       |정수                               |4  |-2,147,483,648 ~ 2,147,483,647<br>±21억
6|uint      |unsigned int<br>부호 없는 정수     |4  |	0 ~ 4,294,967,295<br>42억
7|long      |정수                               |8  |–9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807<br>±922경
8|ulong     |unsigned long<br>부호 없는 정수    |8  |0 ~ 18,446,744,073,709,551,615<br> 1844경
9|char      |유니코드 문자                      |2





### 1.2. 부동 소수 계열 형식

번호|데이터 형식|설명|크기(byte)|값의 범위
----|-----|-----|-----|-----
1|float     |단일 정밀도 부동 소수점 형식<br>7개의 자릿수   |4  |-3.402823e38 ~ 3.402823e38
2|double    |복수 정밀도 부동 소수점<br>15~16개의 자릿수    |8  |-1.79769313486232e308 ~ 1.79769313486232e308

- 단점
    1. 소수점, 부호 표현을 위해 비트를 사용함
    2. 정수 계열 형식보다 산술 연산이 느림
    3. 정밀도 한계. 데이터 손실이 발생





### 1.3. 고정 소수 계열 형식

데이터 형식|설명|크기(byte)|값의 범위
-----|-----|-----|-----
decimal   |정수와 소수를 표현하는 비트 수를 미리 정함<br>28~29개의 자릿수|16|±1.0*10e ~ ±7.9*10e28





### 1.4. 크기가 서로 다른 형식간 변환
1. 오버플로우를 주의
2. 데이터 정밀성 손상을 주의
    - Q: "0.1은 부동 소수점 형식의 범위에서 벗어나지 않는데, 정밀성에 손상이 있을까?"
    - A: 십진수 0.1을 이진수로 바꾸면 0.0001100110011...으로, 무한히 반복한다. 형식의 범위에 벗어나지 않도록 근사하는 과정에서 정밀성에 손상이 생긴다.





## 2. 논리 형식
- `bool`
- `true`, `false`
- 1byte





## 3. 문자열 형식
- `string`

### 3.1. 문자열과 숫자간 변환

- 문자열을 숫자로 변환  
    - Convert  
        - 지원 형식: `Boolean` `Char` `SByte` `Byte` `Int16` `Int32` `Int64` `UInt16` `UInt32` `UInt64` `Single` `Double` `Decimal` `DateTime` `String`
        
        - 인수 형식이 맞지 않는 경우 `FormatException`을, `null`인 경우 `0`을 반환
        - 예외 처리 없음

        ```c#
        // 정수 형식
        string textInt = "123";
        int number = Convert.ToInt16(textInt) // (16: short), (32: int), (64: long)
        ```
        
    - Parse
        - `Type.Parse(string)`
        - 인수 형식이 올바르지 않은 경우 `FormatException`반환
        -  `null`인 경우 `ArgumentNullException`을 반환

        ```c#
        // 부동소수점 형식
        string textFloat = "1.23456";
        float numFloat = float.Parse(textFloat);
        ```


- 숫자를 문자열로 변환할 때  
    - `Object.ToString()`
        ```c#
        int number = 123;
        string text = number.ToString();
        ```








## 4. 오브젝트 형식 Object Type
- 모든 데이터 형식의 부모
    - 모든 데이터가 자동으로 오브젝트 형식을 상속받음
- 따라서 `object`는 모든 데이터를 다룰 수 있음

### 4.1. 박싱과 언박싱 Boxing and Unboxing  
*"박싱을 하면 단순히 참조에 할당하는 것보다 20배까지 시간이 소모되며, 언박싱은 할당에 4배정도 소모된다.*"

- Boxing
    - 값 형식을 `Object` 형식이나 이 값 형식에서 구현된 임의의 인터페이스 형식으로 변환하는 것
    - 스택 영역에 있는 값을 힙에 할당하고 스택에는 주소를 담음

- Unboxing
    - `Object` 형식에서 값 형식으로, 또는 인터페이스 형식에서 해당 인터페이스를 구현하는  값 형식으로 변환하는 것
    - 과정
        1. 인스턴스가 지정한 값 형식을 박싱한 값인지 확인
        2. 인스턴스 값을 값 형식 변수에 복사
    - 다른 형식으로 언박싱하거나 해당 형식보다 작은 범위로 변환을 하면 오류(`InvalidCastException`)가 발생
    - `is` 연산자로 같은 형식인지 확인 후 캐스팅 하자







# 상수 형식
- 키워드: `const`
- 반드시 데이터를 대입

```c#
const 자료형 식별자 = 값;
const int   count = 3;
```

# 열거 형식
- 키워드: `enum`
- 같은 범주에 속하는 여러 개의 상수를 선언할 때
- 자료형은 정수계열만 사용 가능
- 0부터 차례로 숫자를 부여
```c#
enum enumTypeName : int { 상수1, 상수2, 상수3 ...}

// 자료형 생략시 컴파일러가 int를 기반자료형으로 사용
enum DialogResult {YES, NO, CANCEL, CONFIRM, OK}
// int 로 형변환해야 숫자가 출력됨
Console.WriteLine((int)DialogResult.OK);
// 결과 5
```






# Nullable 형식







# 복합 데이터 형식
## 클래스
- 데이터와 데이터를 처리하는 메소드로 이루어짐
- 클래스는 복합 데이터 형식(`object` type)
- 멤버
    1. 필드
        - `C`/`C++`와 달리 전역변수를 지원하지 않는 대신 필드가 존재
    2. 메소드
    3. 프로퍼티
    4. 이벤트
    5. 기타

```c#
Cat kitty;
// kitty자체에 메모리가 할당되는 것이 아니라 참조로써 객체가 있는 곳을 가리킨다.
// 쓰레기값
```

```c#
Cat kitty = new Cat();
// `new`연산자와 생성자를 이용해 힙에 객체를 생성
// `kitty`가 힙에 생성된 객체를 가리킴
```